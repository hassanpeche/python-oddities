<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Python Oddities Explained</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Python Oddities Explained</h1>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            TODO
          </aside>
        </section>

        <!--

          - Make sure >>> is hidden in cases where there's something to be revealed
          - not too much on identity: maybe explain identity vs equality to setup mutability
          - remove [0] * 3 oddities
          - a += b is not always the same as a = a + b... but sometimes it is!
          - List can contain itself
          - final takaways:
            - Variables in Python are pointers: so variable assignments don't copy things, they just change the object that a particular variable name points to
            - the word change is ambiguous: "can't change variable X" could mean it's out of scope and can't be assigned to or could mean the object that X currently points to is immutable
            - containers don't contain objects, they just contain references to objects... two containers can "contain" to the same object and objects can "contain" themselves
            - += is not always the same as = +... it is for tuples, strings, and numbers, but not on lists

        -->

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos" alt="Truthful Technology"></a>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos" alt="Python Morsels"></a>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey
            - I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - And I run a Python exercise subscription service where where I send out 1 Python exercise every week.  It's called Python Morsels.
          </aside>
        </section>

        <section>
          <h1>I teach Python to teams</h1>
          <h3 class="fragment">My students ask very interesting questions</h3>
          <h3 class="fragment"><q>That's odd.  What's going on here?</q></h3>
          <aside class="notes" data-markdown>
            - So when I do on-site trainings with teams, **(click)** my students often ask questions about their code that doesn't do what they think it should do
            - Sometimes this code is pretty straightforward to explain, but sometimes it's a little harder to explain what's going on **(click)**
            - This talk is inspired by the types of questions that I've been asked in my training sessions
          </aside>
        </section>

        <section>
          <h2>This talk supports Python 3 only</h2>
          <h3 class="fragment">If you need a reason to upgrade, ask me what oddities Python 2 has</h3>
          <aside class="notes" data-markdown>
            - This is a Python 3 only talk
            - There are parts of this talk that may apply to Python 2, but I don't that everything will work quite the same way
            - So if you're on Python 2, you'll need to test these things out on your own
            - If this talk was a Python 2 oddities talk, it would be funnier and longer **(click)**
            - So if you *are* on Python 2 and you'd like to me to help convince you to upgrade, ask me about Python 2 oddities
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Errors of Equality</h2>
          <aside class="notes" data-markdown>
            - Let's talk about equality
          </aside>
        </section>

        <section>
          <h3><span class="fragment" data-fragment-index=5>Equality </span><span class="fragment" data-fragment-index=6>and Identity</span></h3>
          <pre class="python"><code data-trim data-noescape>
>>> a = [1, 2]
>>> b = [1, 2]
>>> <span class="fragment" data-fragment-index=1>a == b</span>
<span class="fragment" data-fragment-index=2>True
>>> </span><span class="fragment" data-fragment-index=3>a is b</span>
<span class="fragment" data-fragment-index=4>False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have two lists, `a` and `b`.
            - They have the same items, so if we ask whether a is equal to be **(click)**, we'll see that this is True **(click)**
            - If we ask whether a **is** b **(click)**, we'll see that that's False **(click)**
            - The first question is asking about equality **(click)** between `a` and `b`
            - The second question is asking about identity **(click)**: we're asking whether `a` and `b` are exactly the same object in memory.  Which they aren't.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> a = [1, 2]
>>> b = [1, 2]
>>> <span class="fragment">a is b
False
>>> </span><span class="fragment">id(a), id(b)
(140678342682600, 140678342683752)
>>> </span><span class="fragment">c = a
>>> </span><span class="fragment">id(a), id(c)
(140678342682600, 140678342682600)
>>> </span><span class="fragment">a == c
True
>>> </span><span class="fragment">a is c
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - The question **(click)** `a is b` is asking whether the memory location of each these two objects is the same, **(click)** which it's not in this case
            - If we assign the variable `c` **(click)** to the variable `a`, we'll see that `c` and `a` now point to the same object in memory, **(click)** which means they're not just equal **(click)**: they're also identical **(click)**
            - If this is a little tricky to wrap your head around, don't worry because it'll come up again when we talk about mutability later
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = 999
>>> </span><span class="fragment">y = 999
>>> </span><span class="fragment">x == y
</span><span class="fragment">True
>>> </span><span class="fragment">x is y
</span><span class="fragment">False
>>> </span><span class="fragment">x = 4
>>> </span><span class="fragment">y = 4
>>> </span><span class="fragment">x is y
</span><span class="fragment">True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's take two variables and assign them each to the same number.
            - `x` is `999` **(click)** and so is `y` **(click)**
            - Does `x` equal `y`? **(click)** *(pause)* Yes. **(click)**
            - Is `x` identical to `y`? **(click)** *(pause)* No **(click)**, they're not identical.  Python stores these two objects separately.
            - Somewhat strangely... if `x` **(click)** and `y` **(click)** are both `4`, and we ask the same question **(click)**... we'll see that this time `x` and `y` *are* identical **(click)**
            - What's going on here?
            - *(pause)*
            - So Python treats some numbers differently than others...
            - Some numbers will always be identical to the same number in Python
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
lots_of_numbers = range(-1000, 1000)
the_same_numbers = range(-1000, 1000)
same_numbers = (
    i
    for i, j in zip(lots_of_numbers, the_same_numbers)
    if i is j
)
print(*same_numbers, sep=", ")
          </code></pre>
          <aside class="notes" data-markdown>
            - We can see which numbers are special by looping over a wide range of numbers and printing out the ones that are identical to each other whenever they're equal... even when they'd normally be different objects in memory
          </aside>
        </section>

        <section>
          <pre class="no-highlight"><code class="hljs" data-trim style="overflow: hidden;">
-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112
113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,
126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,
139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,
152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,
243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256
          </code></pre>
          <aside class="notes" data-markdown>
            - The special numbers in Python are -5 through 256
            - The CPython runtime, that's the default python command that you run on your computer, it considers these numbers to be very common, so it stores them in memory at all times and makes sure that anytime we see one of these numbers, it uses the one that's already being stored, so it doesn't take up any extra memory
            - Python also does something similar for strings
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = 'a' * 10
>>> y = 'a' * 10
>>> </span><span class="fragment">x is y
</span><span class="fragment">True
>>> </span><span class="fragment">x = 'a' * 1000
>>> y = 'a' * 1000
>>> </span><span class="fragment">x is y
</span><span class="fragment">False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we have two fairly short strings **(click)** that are equal to each other, and we ask whether they're identical **(click)**, Python will tell us that they are **(click)**
            - But if we have longer strings **(click)** that are also equal to each other, and we ask whether they're identical **(click)**, Python will tell us that they aren't **(click)**
            - This isn't quite as straightforward as the integer optimization we just saw though
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> x = 'a' * 1000
>>> y = 'a' * 1000
>>> </span><span class="fragment">m = x[:10]
>>> n = y[:10]
>>> </span><span class="fragment">m is n
</span><span class="fragment">False
>>> </span><span class="fragment">m, n
('aaaaaaaaaa', 'aaaaaaaaaa')
>>> </span><span class="fragment">m == n
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Because if we take those long strings, and we slice them **(click)** to get short ones again
            - And then we ask whether those short strings are identical **(click)**, we'll see that they aren't **(click)**
            - Despite the fact that they represent the same characters **(click)**
            - And they are equal to each other **(click)**
          </aside>
        </section>

        <section>
          <h3>So... should you ever use the <code>is</code> operator?</h3>
          <h4 class="fragment">Yes, when you care about identity, not just equality</h4>
          <aside class="notes" data-markdown>
            - So at after these oddities, you might be thinking, the `is` operator seems like it's not actually very useful and might be misleading to use
            - But `is` *is* useful, it's just not as commonly useful as `==`
            - The `is` operator is useful **(click)** whenever you actually *care* whether two objects are identical... the same exact object in memory... and not just equal to each other
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
def from_node(node):
    node_list = []
    while <span class="fragment bold-current">node is not None</span>:
        node_list.append(node)
        node = node.next
    return node_list

<span class="fragment">def is_iterator(iterable):
    """Return True if the given iterable is also an iterator."""
    return iter(iterable) is iterable</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - PEP8, the official Python style guide, recommends using the `is` operator for comparisons with singletons **(click)** like `None` and `True` because they'll always be identical to each other
            - That's probably the most common use of the `is` operator in Python, but there are *other* uses
            - Relying on identity is useful if you want to know whether you're looking at two *different* objects or just *one* object with multiple names
            - For example **(click)** here we're checking whether an object is an iterator by seeing whether its iterator is identical to itself
            - So...
          </aside>
        </section>

        <section>
          <h2>Takeaways</h2>
          <ul>
            <li class="fragment">Equality and identity are different</li>
            <li class="fragment">Checking for equality is very common</li>
            <li class="fragment">Checking for identity is not nearly as common</li>
            <li class="fragment">Python includes optimizations that make for strange identity patterns with strings and numbers</li>
            <li class="fragment">Checking for identity when you need equality causes bugs</li>
          </ul>
          <aside class="notes" data-markdown>
            - The takeaways from these equality and identity oddities are that...
            - **(click)** Equality and identity are not the same thing
            - **(click)** The `==` operator is much more commonly useful than the `is` operator
            - **(click)** If you're wondering whether you want equality or identity, most of the time you want equality
            - **(click)** Python includes some optimizations that involve making some strings and numbers identical when the aren't really
            - **(click)** So if you find yourself using `is` when you shouldn't, your code may actually have some very hard to catch bugs
          </aside>
        </section>

      </section>
      <section>

        <section>
          <h2>Scope Scares</h2>
          <aside class="notes" data-markdown>
            - Let's talk about variable scope
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>x = 0
>>> </span><span class="fragment" data-fragment-index=2>numbers = [1, 1, 2, 3, 5, 8]
>>> </span><span class="fragment" data-fragment-index=3><span class="fragment bold-current" data-fragment-index=8>for x in numbers</span>:
...     y = x**2
...
>>> </span><span class="fragment" data-fragment-index=4>y</span>
<span class="fragment" data-fragment-index=5>64</span><span class="fragment" data-fragment-index=6>
>>> x</span>
<span class="fragment" data-fragment-index=7>8</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have a variable `x` **(click)** that is equal to `0` and a variable `numbers` **(click)** that points to a list of numbers
            - If we loop **(click)** over this list of numbers and assign `y` to the square of each number
            - What will we see if we access `y` **(click)** after this loop?
            - **(click)** 64!
            - What will we see if we access `x` **(click)** now?
            - **(click)** 8!
            - Unlike many other programming languages, loops leak their scope in Python
            - Variables defined inside a loop are accessible outside of the loop
            - And that **(click)** `for x in numbers` in actually **an assignment** that happens during each iteration of our loop.  It works the same way as an assignment using an equals sign.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = 0
>>> </span><span class="fragment">numbers = [1, 1, 2, 3, 5, 8]
>>> </span><span class="fragment">squares = [x**2 for x in numbers]
>>> </span><span class="fragment">x</span>
<span class="fragment">0</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we take those same `x` **(click)** and `numbers` **(click)** variables and we make a list comprehension **(click)** representing the squares of these numbers and we use `x` **(click)** as our looping variable
            - What will `x` **(click)** be after we've executed all this code?
            - x is actually still 0 here **(click)**
            - ... In Python 3 that is.  In Python 2, list comprehensions used to leaked their scope, but in Python 3, list comprehensions have their own separate scope.
          </aside>
        </section>

        <!--
        <section>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1]
>>> <span class="fragment">class A:
...     numbers = [2]
...     m = 3
...     squares = [n**2 for n in numbers]
...
>>> </span><span class="fragment">numbers[0], A.numbers[0], A.m, A.squares[0]
</span><span class="fragment">(1, 2, 3, 4)</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's make a list, called `numbers`
            - And a class that has some attributes: `numbers`, `m`, and `squares`
            - I'd like you to consider what *this code* is going to print
            - We have two different `numbers` variables here, one that's global and one that it's in our class
            - Our `squares` variable is the result of a list comprehension that loops over `numbers` and squares each of the numbers
            - Which `numbers` variable is it using?  Will `A.squares[0]` be `1**2` or `2**2`?
            - It's 4, which is `2**2`.  While we're in the process of creating our class, we can access other variables we've defined inside our class.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">class A:
...     numbers = [2]
...     </span><span class="fragment">for n in numbers:
...         print(n**2)
...</span><span class="fragment">
4
>>> </span><span class="fragment">A.numbers
[2]
>>> </span><span class="fragment">A.n
2</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This works because classes have their scope
            - The variables that we assign inside class scope become class attributes
            - And we're actually allowed to write arbitrary code inside a class as we define it
            - So we can write a `for` loop inside our class definition... which probably isn't something you should ever do, but you can.  This is just code being executed just like it is anywhere else in Python.
            - The interesting thing is that our class has not only a `numbers` attribute, but also an attribute `n`.  This `A.n` is here because we were doing an assignment to `n` in each iteration of our loop.
            - Classes have their own scope, just like functions have their own scope.  All the variables defined inside class scope become class attributes after we've finished defining our class.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">class A:
...     numbers = [1, 2]
...     m = 3
...     </span><span class="fragment">squares = [n**m for n in numbers]
...     </span><span class="fragment">print(squares[0])
...</span><span class="fragment">
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;stdin>", line 3, in A
  File "&lt;stdin>", line 3, in &lt;listcomp>
NameError: name 'm' is not defined</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's define a list, a variable `m` and another list comprehension
            - This time our comprehension will raise `n` to the power of `m`
            - What is this going to print?
            - That was kind of trick question, because we actually get an error
            - Comprehension scope isn't allowed to access class scope
            - This might seem a little weird and it is really is pretty weird, but there's a good reason for this
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> class A:
...     numbers = [1, 2]
...     <span class="fragment">def hi(): print(numbers)
...     hi()
...</span><span class="fragment">
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in A
  File "<stdin>", line 3, in hi
NameError: name 'numbers' is not defined</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we define a function inside of a class definition
            - And then we call that function
            - We'll get an error if that function accesses variables that are within class scope
            - This happens this way because otherwise class scope would leak into the methods that live on your class... and that would be really weird
          </aside>
        </section>
        -->

        <section>
          <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> <span class="fragment">NUMBERS = [1, 2, 3]
>>> </span><span class="fragment">def add_numbers(*numbers):
...     NUMBERS += numbers
...
>>> </span><span class="fragment">add_numbers([4, 5, 6])</span><span class="fragment">
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in add_numbers
UnboundLocalError: local variable 'NUMBERS' referenced before assignment</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have a global variable `NUMBERS` **(click)**
            - And we want to add more numbers to our list by using `+=` **(click)**
            - What will this do if we call `add_numbers` with the list `[4, 5, 6]`? **(click)**
            - It could modify `NUMBERS`.  It could make a local variable `NUMBERS`.  It could give an error.
            - It does give us an error **(click)**
            - The `+=` operator both reads from and assign to the variable on its left-hand side.  So we're trying to both read from a global variable and assign to a global variable
            - Python doesn't like that
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> NUMBERS = [1, 2, 3]
>>> <span class="fragment">def set_numbers(*numbers):
...     print(NUMBERS)
...     NUMBERS = numbers
...</span><span class="fragment">
>>> set_numbers([4, 5, 6])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in set_numbers
UnboundLocalError: local variable 'NUMBERS' referenced before assignment</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we make a function **(click)** that prints `NUMBERS` and then assigns to it, calling that function will also give us an error **(click)**
            - Variable names in Python functions cannot be both local and non-local/global in the same scope
            - So we can't read a global variable and then later write to a local variable with the same name.  Python doesn't allow that because that's probably a bug in your code.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> NUMBERS = [1, 2, 3]
>>> def print_numbers():
...     print(NUMBERS)
...
>>> print_numbers()
[1, 2, 3]
          </code></pre>
          <aside class="notes" data-markdown>
            - We're allowed to **read** a global variable *without* writing to it
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
<span class="fragment bold-current" data-fragment-index=6>>>> NUMBERS = [1, 2, 3]</span>
>>> <span class="fragment" data-fragment-index=1>def set_numbers(*numbers):
...     <span class="fragment bold-current" data-fragment-index=5>NUMBERS = numbers</span>
...     <span class="fragment bold-current" data-fragment-index=7>print(NUMBERS)</span>
...
>>> </span><span class="fragment" data-fragment-index=2>set_numbers(<span class="fragment bold-current" data-fragment-index=5>[4, 5, 6]</span>)</span>
<span class="fragment" data-fragment-index=3>[4, 5, 6]
>>> </span><span class="fragment" data-fragment-index=4><span class="fragment bold-current" data-fragment-index=8>NUMBERS
[1, 2, 3]</span><span class="fragment bold-current" data-fragment-index=10></span></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - But if we assign to a variable **(click)**, it's a local variable
            - So if we call this function **(click)**, it'll print out the list we gave to it **(click)**
            - But the global variable hasn't changed **(click)**
            - We can assign to a local variable **(click)**, that happens to have the same name as a global **(click)**, and then print it **(click)**
            - but calling this function doesn't change our global `NUMBERS` variable **(click)**
            - The global `NUMBERS` variables is shadowed by the local `NUMBERS` variable because it has the same name
            - There *is* a special statement that allows you to change global variables in Python, but I'm not going to show you how to do it because using it is usually a bad idea
            - You should trust Python's variable scope rules.  They tend to be pretty good about both saving you from bugs and pushing you in the direction of storing your variables in the right scope.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> NUMBERS = [1, 2, 3]
>>> <span class="fragment">def add_numbers(*numbers):
...     NUMBERS.extend(numbers)
...     print(NUMBERS)
...
>>> </span><span class="fragment">add_numbers([4, 5, 6])</span>
<span class="fragment">[1, 2, 3, 4, 5, 6]


</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we take our `add_numbers` function and use the `extend` **(click)** method instead of an assignment, is this any different?
            - What will Python do when we call this function **(click)** this time? *(pause)*  Will it print out 1, 2, 3, 4, 5, 6 or will it give us an error?
            - This actually works... **(click)**
            - I said before that we can't change our global `NUMBERS` variable, but it seems kinda like we changed our `NUMBERS` variable here!
            - You'll see this gotcha come up quite a bit... the word "change" is ambiguous
            - When I say we can't change `NUMBERS`, I meant that we can't *assign* to `NUMBERS`
            - Assigning to numbers changes the object that the global variable `NUMBERS` points to and that's not allowed unless we're in the same scope as `NUMBERS`
            - But we're not assigning to `NUMBERS`, we're mutating it.
            - We *are* allowed to mutate any object that we can get our hands on though, so long as it's mutable
            - So we're only allowed to assign to local variables, but we can mutate any object as long as it's not immutable.
          </aside>
        </section>

        <section>
          <h2>Takeaways</h2>
          <ul>
            <li class="fragment">Reading global variables is perfectly fine</li>
            <li class="fragment">But don't try to assign to them from a local scope</li>
            <li class="fragment">List comprehensions have their own scope</li>
            <li class="fragment">Scope matters with assignment, not with mutation</li>
          </ul>
          <aside class="notes" data-markdown>
            - So you're allowed to *read* from global variables in Python
            - But you can only write to local variables: every assignment statement assigns to a *local* variable
            - There are some escape hatches in the language to get around that, but in general you should assume that assignments only work for local variables
            - List comprehensions have their own scope
            - Scope rules are entirely about assignment.  You don't need to worry about scope if you're just mutating an object.  It's when you're assigning that things get weird.
            - That leads us to our next topic...
          </aside>
        </section>

      </section>
      <section>

        <section>
          <h2>Teenage Mutable Ninja Turtles</h2>
          <aside class="notes" data-markdown>
            - Mutability: that's changing objects, not variables
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">numbers = [1, 2, 3]
>>> </span><span class="fragment">numbers2 = numbers
>>> </span><span class="fragment">numbers2.append(4)
>>> </span><span class="fragment">numbers2
[1, 2, 3, 4]
>>> </span><span class="fragment">numbers
</span><span class="fragment">[1, 2, 3, 4]
>>> </span><span class="fragment">id(numbers)
139670455619848
>>> id(numbers2)
139670455619848
>>> </span><span class="fragment">numbers is numbers2
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have a list of `numbers`
            - And we assign `numbers2` to `numbers`
            - If we append to `numbers2`, how many elements will `numbers2` contain now?
            - `numbers2` has 4 things in it
            - How many things does `numbers` have?
            - `numbers` *also* has 4 things
            - We're referencing *the same object* with *two* different names
            - Mutating one of these lists, mutates the other... because they're **the same** list
            - **Objects** are *distinct* from the **variables** that point to them
            - "Changing" a *variable* means changing **which object** the variable points to... the only way to do that is through assignment
            - And nothing gets copied during an assignment, we're just giving another name to an object
            - "Changing" an *object* means **mutating** the object itself.  And any number of variables might be pointing to that object that you're changing.
            - Variables in Python are **not buckets** that contain objects
            - Python's variables are pointers that refer to the memory location that objects live at
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">[0] * 3
</span><span class="fragment">[0, 0, 0]
>>> </span><span class="fragment">[[0] * 3] * 3
</span><span class="fragment">[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
>>> </span><span class="fragment">matrix = [[0] * 3] * 3
>>> </span><span class="fragment">matrix[1][1] = 1
>>> </span><span class="fragment">matrix
</span><span class="fragment">[[0, 1, 0], [0, 1, 0], [0, 1, 0]]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - What will this give us? **(click)**
            - This gives us a list of three zeros. **(click)**  We're allowed to multiply lists by numbers in Python, the same way we can multiple strings by numbers (which I think I did earlier)
            - What will this give us? **(click)** *(pause)*
            - This gives us a list of three lists **(click)**, each with three zeroes in them.
            - So this **(click)** `matrix` variable now points to a list of lists of numbers
            - When we assign `matrix[1][1]` to the number `1` **(click)**
            - What will change in `matrix`? **(click)**
            - This actually changes the middle number in all three of the inner lists **(click)**
            - Let's take a look at what's going on here... with a little aside
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">row = [0, 0, 0]
>>> </span><span class="fragment">matrix = [row, row, row]
>>> </span><span class="fragment">row[1] = 2
>>> </span><span class="fragment">matrix
</span><span class="fragment">[[0, 2, 0], [0, 2, 0], [0, 2, 0]]
>>> </span><span class="fragment">matrix[1][1] = 1
>>> </span><span class="fragment">matrix
[[0, 1, 0], [0, 1, 0], [0, 1, 0]]
>>> </span><span class="fragment">matrix[0] is matrix[1] is row
True
>>> </span><span class="fragment">matrix = [row] * 3
</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we have a list of zeroes that we assign to the `row` variable, and we make a new list that contains that `row` variable three times
            - We'll have made a list that contains the same exact list three times
            - If we modify that `row` list, and we look at our `matrix` afterward, we'll see that all of our matrix rows have been modified.  We modified one list that was stored in that list three times.
            - Likewise, if we modify any one of those row lists by indexing them, it'll modify all three rows
            - All of these things are identical.  They all refer to exactly the same object in memory.
            - TODO [row] * 3 is the same as [row, row, row]
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> x = []
>>> <span class="fragment">x.append(x)
</span><span class="fragment">>>> <span class="fragment">x
[[...]]
>>> </span><span class="fragment">[[...]]</span><span class="fragment">
[[Ellipsis]]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - The important takeaway here is that **lists don't actually contain objects**, they *reference* objects.  You can prove this by making a list that contains itself **(click)**
            - Python allows us to put lists inside themselves because lists don't actually contain objects, they just contain pointers to objects **(click)**
            - That notion of **containment** is a *convenient* way to think of things, but it's not like containment in the real world.  It's more like a lookup table.  Variables tell you where to go to locate the object.
            - By the way, **(click)** if you type a couple lists with three dots in them, that's, *somewhat strangely*, valid Python code **(click)**
            - I'm not going to explain what's going on here outside of saying that Python has a special ellipsis variable and that first ellipsis has nothing to do with the second one
            - Alright moving quickly past that oddity...
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = ([1], [4])</span><span class="fragment">
>>> </span><span class="fragment">x[0].append(2)</span><span class="fragment">
>>> </span><span class="fragment">x
([1, 2], [4])
>>> </span><span class="fragment">y = x[0]
>>> </span><span class="fragment">y.append(3)
>>> </span><span class="fragment">x[0]
[1, 2, 3]
>>> </span><span class="fragment">x
([1, 2, 3], [4])</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we make a **(click)** tuple of lists, will Python allow this?  Is that valid?
            - It is! **(click)**  Python allows us to put lists inside of tuples
            - What if call the **(click)** `append` method on the first list in this tuple?  Will Python allow that?
            - It will!  **(click)**  Python doesn't give an error here.
            - This tuple now has a list in it that has two items, but it only one item in it before
            - Tuples in Python are **immutable**, meaning we cannot change them.  And we haven't changed this tuple... at least not from Python's perspective.
            - If we assign this list to a variable `y` **(click)** and we append to `y` **(click)**, we'll change `y` and we'll change **(click)** the original list, because they point to the same object  **(click)**
            - Assignment doesn't copy objects, it just gives another name to them
            - Adding something to a tuple, a list, or a dictionary also doesn't copy anything.  These data structures don't store objects, they store **references** to objects.
          </aside>
        </section>

        <section>
          <h2>Takeaways</h2>
          <ul>
            <li class="fragment">Variables in Python are not buckets that contain things</li>
            <li class="fragment">Variables are names that point to objects</li>
            <li class="fragment">Assigning to a variable changes what object it points to</li>
            <li class="fragment">Mutating an object changes the object itself</li>
            <li class="fragment">Lists and dictionaries don't "contain" objects, they contain references (pointers) to objects</li>
            <li class="fragment">Watch <a href="https://www.youtube.com/watch?v=_AEJHKGk9ns">Facts and Myths about Python names and values</a></li>
            <li class="fragment">Watch <a href="https://pyvideo.org/pyohio-2011/pyohio-2011-names-objects-and-plummeting-from.html">Names, Objects, and Plummeting From The Cliff</a></li>
          </ul>
          <aside class="notes" data-markdown>
            - Variables in Python aren't buckets that contain things **(click)**: they're pointers that reference objects **(click)** by giving them another name
            - Changing variables means changing pointers **(click)**
            - Changing objects means mutating them, but not doing an assignment **(click)**
            - When we talk about whether variables can be changed, we're talking about scope
            - But when we talk about whether objects can be changed we're talking about mutability
            - That word change is loaded because variables and objects are separate things
            - The same rules apply to data structures as variables **(click)**: lists, tuples, and dictionaries don't contain objects, they contain pointers
            - If you feel rusty on this topic, there's two talks I'd recommend watching... TODO
          </aside>
        </section>

      </section>
      <section>

        <section>
          <h2>Intriguing In-Place Additions</h2>
          <aside class="notes" data-markdown>
            - Let's talk a little bit more about `+=`
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">a = b = [1, 2]
>>> </span><span class="fragment">a += [3, 4]
>>> </span><span class="fragment">a
</span><span class="fragment">[1, 2, 3, 4]
>>> </span><span class="fragment">b
</span><span class="fragment">[1, 2, 3, 4]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">a = b = (1, 2)
>>> </span><span class="fragment">a += (3, 4)</span><span class="fragment">
>>> </span><span class="fragment">a
</span><span class="fragment">(1, 2, 3, 4)
>>> </span><span class="fragment">b
</span><span class="fragment">(1, 2)</span>

          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <!--
        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = [1, 2]
>>> </span><span class="fragment">x += (3, 4)</span><span class="fragment">
>>> x</span><span class="fragment">
[1, 2, 3, 4]
>>> </span><span class="fragment">y = (1, 2)
>>> </span><span class="fragment">y += [3, 4]
</span><span class="fragment">Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: can only concatenate tuple (not "list") to tuple</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = []
>>> </span><span class="fragment">x += "hey"
>>> </span><span class="fragment">x
['h', 'e', 'y']
>>> </span><span class="fragment">x.extend('iterable')
>>> </span><span class="fragment">x
['h', 'e', 'y', 'a', 'i', 't', 'e', 'r', 'a', 'b', 'l', 'e']</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO lists are the odd one here
          </aside>
        </section>
        -->

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = ([1, 2],)
>>> </span><span class="fragment">x[0] += [3, 4]
</span><span class="fragment">Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'tuple' object does not support item assignment
>>> </span><span class="fragment">x
([1, 2, 3, 4],)</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>x = ([1, 2],)
>>> </span><span class="fragment" data-fragment-index=2><span class="bold-current fragment" data-fragment-index=4>x[0] =</span> x[0].<span class="bold-current fragment" data-fragment-index=3>__iadd__([3, 4])</span>  # x[0] += [3, 4]</span>
<span class="fragment" data-fragment-index=5>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'tuple' object does not support item assignment
>>> </span><span class="fragment" data-fragment-index=6>x[0]
[1, 2, 3, 4]
>>> </span><span class="fragment" data-fragment-index=7>x[0].__iadd__([5])
[1, 2, 3, 4, 5]
>>> </span><span class="fragment" data-fragment-index=8>x[0] = [1, 2, 3, 4, 5]
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'tuple' object does not support item assignment</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <!--
        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">NUMBERS = [1, 2, 3]
>>> </span><span class="fragment">class MyFavoriteClass:
...     NUMBERS += [4, 5, 6]
...</span><span class="fragment">
>>> </span><span class="fragment">MyFavoriteClass.NUMBERS
[1, 2, 3, 4, 5, 6]
>>> </span><span class="fragment">NUMBERS
</span><span class="fragment">[1, 2, 3, 4, 5, 6]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">VOWELS = "aeiou"
>>> </span><span class="fragment">class B:
...     VOWELS += "y"
...</span><span class="fragment">
>>> </span><span class="fragment">B.VOWELS
'aeiouy'
>>> </span><span class="fragment">VOWELS
'aeiou'</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>
        -->

        <section>
          <h2>Takeaways</h2>
          <ul>
            <li class="fragment">In-place addition (<code>+=</code>) and other augmented assignment operations perform assignments</li>
            <li class="fragment">In-place addition calls the <code>__iadd__</code> method which allows the object to mutate itself if it chooses to do so</li>
            <li class="fragment">Python's choice about what makes for consistent behavior may differ from your own assumptions</li>
            <li class="fragment">Class scope is a little magical</li>
          </ul>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

      </section>
      <section>

        <section>
          <h2>Operator Obtusity</h2>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">'Python' in 'Python' in 'Python'
</span><span class="fragment">True
>>> </span><span class="fragment">'Python' in 'Python'
True
>>> </span><span class="fragment">True in 'Python'
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'in &lt;string>' requires string as left operand, not bool
>>> </span><span class="fragment">'Python' in 'Python' in 'Python'
True
>>> </span><span class="fragment">('Python' in 'Python') in 'Python'
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'in &lt;string>' requires string as left operand, not bool
>>> </span><span class="fragment">'Python' in ['Python'] in [['Python']]
True
>>> </span><span class="fragment">x = 25
>>> 10 &lt; x &lt; 20
False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO chained comparisons can actually be really handy
          </aside>
        </section>

        <!--
        <section>
          <h2>Star Silliness</h2>
        </section>

        <section>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
>>> <span class="fragment">numbers = range(3)
>>> </span><span class="fragment">*nums1 = numbers</span><span class="fragment">
Traceback (most recent call last):
  File "&lt;stdin>", line 1
SyntaxError: starred assignment target must be in a list or tuple
>>> </span><span class="fragment">*nums2, = numbers</span><span class="fragment">
>>> </span><span class="fragment">nums2
[0, 1, 2]
>>> </span><span class="fragment">[*nums3] = numbers</span><span class="fragment">
>>> </span><span class="fragment">nums3
[0, 1, 2]</span><span class="fragment">
>>> </span><span class="fragment">nums4 = *numbers</span><span class="fragment">
Traceback (most recent call last):
  File "&lt;stdin>", line 1
SyntaxError: can't use starred expression here
>>> </span><span class="fragment">nums5 = [*numbers]</span><span class="fragment">
>>> </span><span class="fragment">nums5
[0, 1, 2]</span><span class="fragment">
>>> </span><span class="fragment">nums6 = *numbers,</span><span class="fragment">
>>> </span><span class="fragment">nums6
(0, 1, 2)</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO Python 3.5 added a lot of new generalizations for star expressions.  You should play with them.  The examples I showed here are silly, but these can actually be really useful.
          </aside>
        </section>
        -->

        <section>
          <h2>Miscellaneous Mishaps</h2>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> nums = reversed([1, 2, 3, 4])
>>> 2 in nums
True
>>> 2 in nums
False
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO I explain this one in my Loop Better talk that I presented at PyGotham last year
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h1>#pythonoddity</h1>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <h2>Closing thoughts</h2>
          <ul>
            <li class="fragment">Understanding how variables, mutability, and data structures work is important</li>
            <li class="fragment">If it looks like a bug, it might just be a misunderstanding</li>
            <li class="fragment">Found something odd? Try to learn from it!</li>
          </ul>
          <aside class="notes" data-markdown>
            - Regardless of what programming language you're in, it's important to understand how the fundamentals of your programming language is different: how do function calls work, how variables work, and do objects works?
            - And if you think you found a bug in Python, it might just be that you're misunderstanding what trade offs the Python code developers had to make when they chose the particular functionality that you're seeing
            - So if you see something odd going on, *before* you fix your code, poke around and see whether you can learn from it
            - breaking things is one of the best ways to learn
          </aside>
        </section>

      </section>

			<section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
          <h3>
            <strong>Trey Hunner</strong><br>
            <small>Python &amp; Django Team Trainer</small>
          </h3>
          <p>
            <small>
              Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
            </small>
          </p>
          <p>
          <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
          <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
          </p>
          <aside class="notes" data-markdown>
            - If you're interested in improving your Python skills, send me an email
            - Thank you!
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> '8' &lt; 8
False
>>> '8' &lt; 9
False
>>> '8' &lt; 99999999999999999999999999999999
False
>>> [8] > 8
True
>>> [8] &lt; '8'
True
>>> sorted([type(8), type('8'), type([8])])
[&lt;type 'int'>, &lt;type 'str'>, &lt;type 'list'>]
>>> 8 &lt; '8' &lt; [8]
False
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO we can print without assigning to it
          </aside>
        </section>

      </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
